name: AI Merge & Automerge (stable)

on:
  pull_request:
    types: [labeled, synchronize, reopened]
  workflow_dispatch:
    inputs:
      pull_request_number:
        description: 'Pull request number to resolve'
        required: true

permissions:
  contents: write
  pull-requests: write
  models: read

jobs:
  ai-merge:
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && ((github.event.action == 'labeled' && github.event.label.name == 'ai-resolve') || contains(github.event.pull_request.labels.*.name, 'ai-resolve')))
    runs-on: ubuntu-latest
    env:
      PR_NUMBER: ${{ github.event.pull_request.number || github.event.inputs.pull_request_number || '' }}
      BASE_REF: ${{ github.event.pull_request.base.ref || '' }}
      REPO: ${{ github.repository }}
      EVENT_NAME: ${{ github.event_name }}
      SHOULD_CONTINUE: 'true'

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Resolve conflicts with GitHub Models (LLM)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          PR="${PR_NUMBER}"
          if [ -z "$PR" ]; then
            echo "Pull request number is required."
            exit 1
          fi

          BASE_BRANCH="${BASE_REF}"

          if [ "${EVENT_NAME}" = "workflow_dispatch" ]; then
            LABELS=$(gh pr view "$PR" --repo "${REPO}" --json labels -q '.labels[].name')
            if ! grep -Fxq 'ai-resolve' <<<"$LABELS"; then
              echo "PR #$PR does not have the ai-resolve label. Exiting."
              echo "SHOULD_CONTINUE=false" >> "$GITHUB_ENV"
              exit 0
            fi
            if [ -z "$BASE_BRANCH" ]; then
              BASE_BRANCH=$(gh pr view "$PR" --repo "${REPO}" --json baseRefName -q .baseRefName)
            fi
          fi

          if [ -z "$BASE_BRANCH" ]; then
            BASE_BRANCH=$(gh pr view "$PR" --repo "${REPO}" --json baseRefName -q .baseRefName)
          fi

          BASE_BRANCH=$(echo "$BASE_BRANCH" | tr -d '\r')
          echo "Using base branch $BASE_BRANCH"

          git fetch origin "$BASE_BRANCH"
          if git merge --no-commit --no-ff "origin/$BASE_BRANCH"; then
            echo "No conflicts. Nothing to do."
            exit 0
          fi

          CONFLICTS=$(git diff --name-only --diff-filter=U)
          echo "Conflicted files:"
          echo "$CONFLICTS"

          node - <<'NODE'
          import { execSync } from "node:child_process";
          import fs from "node:fs";

          const GHTOKEN = process.env.GITHUB_TOKEN;
          const conflicts = execSync("git diff --name-only --diff-filter=U").toString().trim().split("\n").filter(Boolean);

          const ALWAYS_THEIRS = [/^dist\//, /^build\//, /\.min\./, /^package-lock\.json$/, /^yarn\.lock$/, /^pnpm-lock\.yaml$/];
          const UNION = [/\.md$/, /\.svg$/, /\.ya?ml$/, /\.json$/];

          const pick = (p)=>ALWAYS_THEIRS.some(r=>r.test(p))?"theirs":UNION.some(r=>r.test(p))?"union":"ai";

          const show = (spec, file) => {
            try { return execSync(`git show ${spec}:${file}`, {stdio:['ignore','pipe','pipe']}).toString(); }
            catch { return ""; }
          }

          const callModel = async (model, messages) => {
            const res = await fetch("https://models.github.ai/inference/chat/completions", {
              method: "POST",
              headers: {
                "Content-Type":"application/json",
                "Authorization":`Bearer ${GHTOKEN}`
              },
              body: JSON.stringify({ model, temperature: 0.1, messages, max_tokens: 8000 })
            });
            if (!res.ok) throw new Error(`Model HTTP ${res.status}`);
            const j = await res.json();
            return j.choices?.[0]?.message?.content ?? "";
          };

          const aiMerge = async (file) => {
            const base = show(":1", file);
            const ours = show(":2", file);
            const theirs = show(":3", file);

            const system = "You merge two conflicting versions of ONE file. Keep buildable, deduplicate imports, keep both intentional changes. Output ONLY the final file.";
            const user = `FILE: ${file}\nBASE:\n${base}\nHEAD:\n${ours}\nINCOMING:\n${theirs}`;

            try {
              const merged = await callModel("openai/gpt-4o-mini", [
                {role:"system", content: system},
                {role:"user", content: user}
              ]);
              if (merged && merged.trim().length>0) return merged;
            } catch(e) {}

            const withMarkers = fs.readFileSync(file,"utf8");
            return withMarkers.replace(/^<<<<<<<[^\n]*\n/gm,"").replace(/^\={7,}\n/gm,"").replace(/^>>>>>>>[^\n]*\n/gm,"");
          };

          const main = async ()=>{
            for (const f of conflicts) {
              const s = pick(f);
              console.log(`Resolving ${f} [${s}]`);
              if (s === "theirs") { execSync(`git checkout --theirs -- "${f}"`); continue; }
              if (s === "union") {
                const txt = fs.readFileSync(f,"utf8").replace(/^<<<<<<<[^\n]*\n/gm,"").replace(/^\={7,}\n/gm,"").replace(/^>>>>>>>[^\n]*\n/gm,"");
                fs.writeFileSync(f, txt); continue;
              }
              const merged = await aiMerge(f);
              fs.writeFileSync(f, merged);
            }
          };
          await main();
          NODE

          if ! git -c core.editor=true merge --continue; then
            for f in $CONFLICTS; do
              sed -i -e '/^<<<<<<< /d' -e '/^=======/d' -e '/^>>>>>>> /d' "$f" || true
            done
            git -c core.editor=true merge --continue || true
          fi

          if [ -f package.json ]; then
            npm ci || npm i
            npm test || true
            npm run build || true
          fi

          if [ -n "$(git status --porcelain)" ]; then
            git config user.name  "ai-merge-bot"
            git config user.email "actions@users.noreply.github.com"
            git add -A
            git commit -m "chore: AI-resolved merge conflicts"
            git push
          fi

      - name: Enable auto-merge if clean
        if: env.PR_NUMBER != '' && env.SHOULD_CONTINUE == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: gh pr merge "$PR_NUMBER" --repo "$REPO" --merge --auto || true
